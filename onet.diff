diff --git a/local.go b/local.go
index a8316e4..95307cc 100644
--- a/local.go
+++ b/local.go
@@ -259,7 +259,7 @@ func (l *LocalTest) WaitDone(t time.Duration) error {
 
 // CloseAll closes all the servers.
 func (l *LocalTest) CloseAll() {
-	log.Lvl3("Stopping all")
+	// log.LLvl3("Stopping all")
 	if r := recover(); r != nil {
 		// Make sure that a panic is correctly caught, as CloseAll is most often
 		// called in a `defer` statement, and we don't want to show leaking
@@ -269,15 +269,36 @@ func (l *LocalTest) CloseAll() {
 	if l.T != nil && l.T.Failed() {
 		return
 	}
-
+	// log.Print()
 	InformAllServersStopped()
 
+	// log.Print()
 	// If the debug-level is 0, we copy all errors to a buffer that
 	// will be discarded at the end.
 	if log.DebugVisible() == 0 {
 		log.OutputToBuf()
 	}
 
+	// For all services that have `TestClose` defined, call it to make
+	// sure they are able to clean up. This should only be used for tests!
+	var wg sync.WaitGroup
+	for _, srv := range l.Servers {
+		srv.serviceManager.servicesMutex.Lock()
+		for _, serv := range srv.serviceManager.services {
+			wg.Add(1)
+			go func(s Service) {
+				defer wg.Done()
+				c, ok := s.(TestClose)
+				if ok {
+					c.TestClose()
+				}
+			}(serv)
+		}
+		srv.serviceManager.servicesMutex.Unlock()
+	}
+	wg.Wait()
+
+	// log.Print(l.Check)
 	if err := l.WaitDone(5 * time.Second); err != nil {
 		switch l.Check {
 		case CheckNone:
@@ -299,17 +320,19 @@ func (l *LocalTest) CloseAll() {
 		}
 	}
 
+	// log.Print()
 	for _, node := range l.Nodes {
-		log.Lvl3("Closing node", node)
+		// log.LLvl3("Closing node", node)
 		node.closeDispatch()
 	}
+	// log.Print()
 	l.Nodes = make([]*TreeNodeInstance, 0)
 
 	sd := sync.WaitGroup{}
 	for _, srv := range l.Servers {
 		sd.Add(1)
 		go func(server *Server) {
-			log.Lvl3("Closing server", server.ServerIdentity.Address)
+			// log.LLvl3("Closing server", server.ServerIdentity.Address)
 			err := server.Close()
 			if err != nil {
 				log.Error("Closing server", server.ServerIdentity.Address,
@@ -324,8 +347,10 @@ func (l *LocalTest) CloseAll() {
 		}(srv)
 	}
 	sd.Wait()
+	// log.Print()
 	l.Servers = map[network.ServerIdentityID]*Server{}
 	l.ctx.Stop()
+	// log.Print()
 
 	os.RemoveAll(l.path)
 	l.closed = true
@@ -333,9 +358,11 @@ func (l *LocalTest) CloseAll() {
 	if log.DebugVisible() == 0 {
 		log.OutputToOs()
 	}
+	// log.Print()
 	if l.Check != CheckNone {
 		log.AfterTest(nil)
 	}
+	// log.Print()
 }
 
 // getTree returns the tree of the given TreeNode
diff --git a/overlay.go b/overlay.go
index 8d8e480..efcc2d5 100644
--- a/overlay.go
+++ b/overlay.go
@@ -158,6 +158,11 @@ func (o *Overlay) TransmitMsg(onetMsg *ProtocolMsg, io MessageProxy) error {
 		// request the PI from the Service and binds the two
 		pi, err = o.server.serviceManager.newProtocol(tni, config)
 		if err != nil {
+			// log.Print(o.ServerIdentity(), "closing")
+			o.instancesLock.Lock()
+			o.nodeDelete(onetMsg.To)
+			o.instancesLock.Unlock()
+			// log.Print(o.ServerIdentity(), "closing done")
 			return err
 		}
 		if pi == nil {
diff --git a/server.go b/server.go
index 5151248..ab73ee5 100644
--- a/server.go
+++ b/server.go
@@ -159,29 +159,16 @@ func (c *Server) Close() error {
 	}
 	c.Unlock()
 
-	// For all services that have `TestClose` defined, call it to make
-	// sure they are able to clean up. This should only be used for tests!
-	c.serviceManager.servicesMutex.Lock()
-	var wg sync.WaitGroup
-	for _, serv := range c.serviceManager.services {
-		wg.Add(1)
-		go func(s Service) {
-			defer wg.Done()
-			c, ok := s.(TestClose)
-			if ok {
-				c.TestClose()
-			}
-		}(serv)
+	err := c.Router.Stop()
+	if err != nil {
+		log.Error("While stopping router:", err)
 	}
-	c.serviceManager.servicesMutex.Unlock()
-	wg.Wait()
 	c.WebSocket.stop()
 	c.overlay.Close()
-	err := c.serviceManager.closeDatabase()
+	err = c.serviceManager.closeDatabase()
 	if err != nil {
 		log.Lvl3("Error closing database: " + err.Error())
 	}
-	err = c.Router.Stop()
 	log.Lvl3("Host Close", c.ServerIdentity.Address, "listening?", c.Router.Listening())
 	return err
 }
diff --git a/service.go b/service.go
index 88784f5..d95b4d3 100644
--- a/service.go
+++ b/service.go
@@ -426,6 +426,10 @@ func (s *serviceManager) serviceByID(id ServiceID) (Service, bool) {
 // the creation of the PI. Otherwise the service is responsible for setting up
 // the PI.
 func (s *serviceManager) newProtocol(tni *TreeNodeInstance, config *GenericConfig) (pi ProtocolInstance, err error) {
+	if s.server.Closed() {
+		err = errors.New("will not pass protocol once the server is closed")
+		return
+	}
 	si, ok := s.serviceByID(tni.Token().ServiceID)
 	defaultHandle := func() (ProtocolInstance, error) { return s.server.protocolInstantiate(tni.Token().ProtoID, tni) }
 	if !ok {
diff --git a/treenode.go b/treenode.go
index 549d351..baaa006 100644
--- a/treenode.go
+++ b/treenode.go
@@ -338,12 +338,18 @@ func (n *TreeNodeInstance) Shutdown() error {
 
 // closeDispatch shuts down the go-routine and calls the protocolInstance-shutdown
 func (n *TreeNodeInstance) closeDispatch() error {
-	log.Lvl3("Closing node", n.Info())
+	defer func() {
+		if r := recover(); r != nil {
+			log.Print("Recovered in f", r)
+			log.Print(log.Stack())
+		}
+	}()
+	// log.LLvl3("Closing node", n.Info())
 	n.msgDispatchQueueMutex.Lock()
 	n.closing = true
 	close(n.msgDispatchQueueWait)
 	n.msgDispatchQueueMutex.Unlock()
-	log.Lvl3("Closed node", n.Info())
+	// log.LLvl3("Closed node", n.Info())
 	pni := n.ProtocolInstance()
 	if pni == nil {
 		return errors.New("Can't shutdown empty ProtocolInstance")
