// This file contains all the code to run one execution of a JVSS-based CoSi
// protocol. It outputs a signature which can be verified against the aggregated
// longterm public keys of all JVSS groups involved.
package randhoundco

import (
	"bytes"
	"errors"

	cosip "github.com/dedis/cosi/protocol"
	"github.com/dedis/cothority/log"
	"github.com/dedis/cothority/protocols/jvss"
	"github.com/dedis/cothority/sda"
	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/poly"
)

const ProtoName = "RandhounCo"

// roundRoot is the leader / root of the tree of a JVSS-based CoSi round.
type roundRoot struct {
	*roundNode
	// the message to sign used by the client role.
	msg []byte
	// the aggregate longterm distributed public key of all JVSS groups
	aggJVSSLongterm abstract.Point
	// reference to the signature generated
	signature []byte
	// function to call when the signature is ready
	signatureHook SignatureHook
}

// roundNode is a node in the tree of a JVSS-based CoSi run.
type roundNode struct {
	*sda.TreeNodeInstance
	// the underlying cosi protocol
	cosi *cosip.CoSi
	// the sid of the short term secret generated for this group
	sid jvss.SID
	// the channel used to dispatch it to the next phase
	secretID chan jvss.SID
	// the aggregated commits of all children + this node
	aggCommit abstract.Point
	// the aggregated response of all children + this node
	aggResponse abstract.Scalar
	// the challenge generated during the challenge phase
	challenge abstract.Scalar
	// the channel to give the signature generated by the JVSS group
	sigDone chan *poly.SchnorrSig
	// the JVSS protocol used for the group the leader is responsible for
	jvss *jvss.JVSS
	// the function to call when the response phase is finished
	onDoneFunc func()
}

// NewRoundRoot returns a protocol instance which is used by the root of
// the tree. It takes a message to be signed by this round, and the aggregated
// distributed public key of all JVSS groups.
func NewRoundRoot(n *sda.TreeNodeInstance, msg []byte, aggJVSSLongterm abstract.Point, jvssP *jvss.JVSS) (sda.ProtocolInstance, error) {
	p, err := NewRoundNode(n, jvssP)
	round := p.(*roundNode)
	rc := &roundRoot{
		roundNode:       round,
		msg:             msg,
		aggJVSSLongterm: aggJVSSLongterm,
	}
	rc.cosi.RegisterCommitmentHook(rc.onCommitment)
	rc.cosi.RegisterResponseHook(rc.onResponse, true)
	return rc, err
}

// NewRandhoundCoNode returns a protocol which designates a leader of a JVSS / group in the big Randhound tree - intermediate node -
func NewRoundNode(n *sda.TreeNodeInstance, jvssP *jvss.JVSS) (sda.ProtocolInstance, error) {
	p, err := cosip.NewCoSi(n)
	if err != nil {
		return nil, err
	}
	go p.Dispatch()
	cosi := p.(*cosip.CoSi)
	rc := &roundNode{
		TreeNodeInstance: n,
		jvss:             jvssP,
		cosi:             cosi,
		secretID:         make(chan jvss.SID),
		sigDone:          make(chan *poly.SchnorrSig),
	}

	rc.cosi.RegisterAnnouncementHook(rc.onAnnouncement)
	rc.cosi.RegisterCommitmentHook(rc.onCommitment)
	rc.cosi.RegisterChallengeHook(rc.onChallenge)
	rc.cosi.RegisterResponseHook(rc.onResponse, true)
	return rc, nil
}

// Start is called by the client to launch a new round. It will pass down an
// Announcement message down the tree.
func (r *roundRoot) Start() error {
	return r.onAnnouncement(&cosip.Announcement{})
}

func (r *roundNode) Start() error {
	return errors.New("I should be put in this position,too much")
}

// onAnnouncement launches the short term distributed secret generation within
// the JVSS group of this leader
func (r *roundNode) onAnnouncement(in *cosip.Announcement) error {
	go func() {
		log.Lvl2(r.Name(), "lauch jvss.SignPrepare()")
		sid, err := r.jvss.SignPrepare()
		if err != nil {
			log.Error(err)
			sid = ""
		}
		r.secretID <- sid
	}()

	// start the commit phase
	if r.IsLeaf() {
		return r.onCommitment([]abstract.Point{})
	}

	// let the announcement going down
	return r.SendToChildren(in)
}

// onCommitment calls the roundNode.onCommitment and then pass to the challenge
// phase. It creates a weirdly formatted message containing all informations to
// create the *real* challenge. It sends that special message down.
func (r *roundRoot) onCommitment(commits []abstract.Point) error {
	err := r.roundNode.onCommitment(commits)
	if err != nil {
		return err
	}
	// H( AggCommit || AggPublic || M)
	hash := r.Suite().Hash()
	if _, err := r.aggCommit.MarshalTo(hash); err != nil {
		return err
	}
	if _, err := r.aggJVSSLongterm.MarshalTo(hash); err != nil {
		return err
	}
	hash.Write(r.msg)
	challenge := r.Suite().Scalar().SetBytes(hash.Sum(nil))
	return r.onChallenge(challenge)
}

// onCommitments collects the short term secret commitment and pass it along
// with the others.
func (r *roundNode) onCommitment(commits []abstract.Point) error {
	// get the random secret
	sid := <-r.secretID
	log.Lvl2(r.Name(), "Got the JVSS Secret")
	r.sid = sid
	secret, err := r.jvss.SharedSecret(sid)
	if err != nil {
		return err
	}

	// get the jvss commit
	commit := secret.Pub.SecretCommit()
	commits = append(commits, commit)
	r.aggCommit = r.Suite().Point().Null()
	for _, c := range commits {
		r.aggCommit.Add(r.aggCommit, c)
	}

	if r.IsRoot() {
		return nil
	}
	comMessage := &cosip.Commitment{r.aggCommit}
	return r.SendToParent(comMessage)
}

// store the challenge, launch the JVSS signature on it and sends it down the tree
func (r *roundNode) onChallenge(challenge abstract.Scalar) error {
	msg, err := challenge.MarshalBinary()
	if err != nil {
		return err
	}
	// start the signing phase of JVSS
	go func() {
		log.Lvl2(r.Name(), "Lauching jvss.SignComplete()")
		sig, err := r.jvss.SignComplete(r.sid, msg)
		if err != nil {
			log.Error(err)
			sig = nil
		}
		r.sigDone <- sig
	}()

	if r.IsLeaf() {
		r.onResponse([]abstract.Scalar{})
		return nil
	}

	return r.SendToChildren(&cosip.Challenge{challenge})
}

// wait on the JVSS signature, collect children's responses and then pass up.
func (r *roundNode) onResponse(resps []abstract.Scalar) {
	defer func() {
		r.cosi.Done()
	}()
	// get the jvss signature
	log.Lvl2(r.Name(), "Waiting on the signature")
	sig := <-r.sigDone
	log.Lvl2(r.Name(), "Waiting on the signature DONE")
	if sig == nil {
		log.Error("No JVSS signature generated onResponse")
		return
	}

	// aggregate the responses
	resps = append(resps, *sig.Signature)
	r.aggResponse = r.Suite().Scalar().Zero()
	for _, resp := range resps {
		r.aggResponse.Add(r.aggResponse, resp)
	}

	if r.onDoneFunc != nil {
		r.onDoneFunc()
	}

	if r.IsRoot() {
		return
	}

	err := r.SendToParent(&cosip.Response{r.aggResponse})
	if err != nil {
		log.Error(err)
	}
}

// RegisterOnDone takes a func that will be called when the roundNode protocol
// is finished (at the end of onResponse).
func (r *roundNode) RegisterOnDone(fn func()) {
	r.onDoneFunc = fn
}

// onResponse computes the aggregation of the children's response, and then
// the signature as a slice of byte equal to:
// AggCommit || AggResponse
// Such  signature can be verified using `VerifySignature`.
// The signatureHook is called if one has been registered.
func (r *roundRoot) onResponse(resps []abstract.Scalar) {
	// aggregate and all
	r.roundNode.onResponse(resps)
	log.Lvl2(r.Name(), "Client: on response -> final step")
	buff := new(bytes.Buffer)
	if _, err := r.aggCommit.MarshalTo(buff); err != nil {
		log.Error(err)
		return
	}
	if _, err := r.aggResponse.MarshalTo(buff); err != nil {
		log.Error(err)
		return
	}
	r.signature = buff.Bytes()
	if r.signatureHook != nil {
		r.signatureHook(r.signature)
	}
}

// SignatureHook is the type of the function that is called when a randhoundco
// signature has been generated.
type SignatureHook func(sig []byte)

// RegisterOnSignature takes a SignatureHook and stores it. This function will
// be called when the signature is generated for a round.
func (r *roundRoot) RegisterOnSignature(fn SignatureHook) {
	r.signatureHook = fn
}

// VerifySignature returns nil if the signature issued for a round of
// randhoundco is valid or an error otherwise. aggPublic is the Aggregate
// Longterm Distributed Public Keys of ALL JVSS groups.
func VerifySignature(suite abstract.Suite, aggPublic abstract.Point, msg, sig []byte) error {
	buffer := bytes.NewBuffer(sig)
	aggCommit := suite.Point()
	if _, err := aggCommit.UnmarshalFrom(buffer); err != nil {
		return err
	}

	aggResponse := suite.Scalar()
	if _, err := aggResponse.UnmarshalFrom(buffer); err != nil {
		return err
	}

	// left: g^r
	left := suite.Point().Mul(nil, aggResponse)

	// right: aggCommit + challenge * aggPublic
	// challenge: H(aggCommit || aggPublic || msg)
	hash := suite.Hash()
	if _, err := aggCommit.MarshalTo(hash); err != nil {
		return err
	}
	if _, err := aggPublic.MarshalTo(hash); err != nil {
		return err
	}
	hash.Write(msg)
	challenge := suite.Scalar().SetBytes(hash.Sum(nil))

	right := suite.Point().Mul(aggPublic, challenge)
	right = right.Add(right, aggCommit)

	if !right.Equal(left) {
		return errors.New("Signature re-created are not equal")
	}
	return nil
}
