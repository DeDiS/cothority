package sign

import (
	log "github.com/Sirupsen/logrus"
	dbg "github.com/dedis/cothority/lib/debug_lvl"

	"errors"
	"github.com/dedis/cothority/lib/coconet"
	"github.com/dedis/cothority/lib/hashid"
	"github.com/dedis/cothority/lib/proof"
	"github.com/dedis/crypto/abstract"
	"github.com/dedis/prifi/coco/sign"
)

// The name type of this round implementation
const RoundCosiType = "stamper"

type RoundCosi struct {
	Suite          *abstract.Suite
	RoundNbr       int
	Node           *sign.Node
								   // Message created by root. It can be empty and it will make no difference. In
								   // the case of a timestamp service however we need the timestamp generated by
								   // the round for this round . It will be included in the challenge, and then
								   // can be verified by the client
	Msg            []byte
	C              abstract.Secret // round lasting challenge
	R              abstract.Secret // round lasting response

	R_hat          abstract.Secret // aggregate of responses

	X_hat          abstract.Point  // aggregate of public keys

	Commits        []*SigningMessage
	Responses      []*SigningMessage

	PubKey         abstract.Point
	PrivKey        abstract.Secret
	Name           string
	Log            sign.SNLog      // round lasting log structure

								   // round-lasting public keys of children servers that did not
								   // respond to latest commit or respond phase, in subtree
	ExceptionList  []abstract.Point
								   // combined point commits of children servers in subtree
	ChildV_hat     map[string]abstract.Point
								   // combined public keys of children servers in subtree
	ChildX_hat     map[string]abstract.Point
								   // for internal verification purposes
	ExceptionX_hat abstract.Point
	ExceptionV_hat abstract.Point

	BackLink       hashid.HashId
	AccRound       []byte

	Vote           *Vote

	Children       map[string]coconet.Conn
	Parent         string
	View           int

}

func init() {
	RegisterRoundFactory(RoundCosiType,
		func(s *sign.Node) sign.Round {
			return NewRoundCosi(s)
		})
}

func NewRoundCosi(node *Node) *RoundCosi {
	cbs := &RoundCosi{}
	cbs.Node = node
	cbs.Commits = make([]*SigningMessage, 0)
	cbs.Responses = make([]*SigningMessage, 0)
	cbs.ExceptionList = make([]abstract.Point, 0)
	cbs.Suite = node.Suite()
	cbs.Log.Suite = cbs.Suite
	return cbs
}

// AnnounceFunc will keep the timestamp generated for this round
func (cs *RoundCosi) Announcement(RoundNbr int, in *sign.SigningMessage, out []*sign.SigningMessage) error {
	am := in.Am
	if am == nil {
		// We are root !
		am = AnnouncementMessage{RoundType: RoundCosiType}
	}
	cs.RoundNbr = RoundNbr
	if err := cs.Node.TryFailure(cs.Node.ViewNo, RoundNbr); err != nil {
		return err
	}

	if err := cs.MerkleSetup(cs.Node.ViewNo, RoundNbr, am); err != nil {
		return err
	}

	// Inform all children of announcement - just copy the one that came in
	for i := range out {
		out[i].Am = am
	}
	return nil
}

func (cs *RoundCosi) Commitment(in []*sign.SigningMessage, out *sign.SigningMessage) error {
	// prepare to handle exceptions
	round := cs
	round.Commits = in
	round.ExceptionList = make([]abstract.Point, 0)

	// Create the mapping between children and their respective public key + commitment
	// V for commitment
	children := round.Children
	round.ChildV_hat = make(map[string]abstract.Point, len(children))
	// X for public key
	round.ChildX_hat = make(map[string]abstract.Point, len(children))

	for key := range children {
		round.ChildX_hat[key] = round.Suite.Point().Null()
		round.ChildV_hat[key] = round.Suite.Point().Null()
	}

	for _, sm := range round.Commits {
		from := sm.From
		// MTR ==> root of sub-merkle tree
		round.ChildV_hat[from] = sm.Com.V_hat
		round.ChildX_hat[from] = sm.Com.X_hat
		round.ExceptionList = append(round.ExceptionList, sm.Com.ExceptionList...)

		// Aggregation
		// add good child server to combined public key, and point commit
		round.Add(round.X_hat, sm.Com.X_hat)
		round.Add(round.Log.V_hat, sm.Com.V_hat)
		//dbg.Lvl4("Adding aggregate public key from ", from, " : ", sm.Com.X_hat)
	}

	com := out.Com
	com.V = cs.Log.V
	com.V_hat = cs.Log.V_hat
	com.X_hat = cs.X_hat
	com.ExceptionList = cs.ExceptionList
	com.Vote = cs.Vote
	com.Messages = cs.Node.Messages
	cs.Node.Messages = 0 // TODO : why ?
	out.Com = com
	return nil

}

func (cs *RoundCosi) Challenge(in *sign.SigningMessage, out []*sign.SigningMessage) error {
	if cs.Node.IsRoot(in.View) {
		// we are root
		cs.C = HashElGamal(cs.Suite, in.Chm.MTRoot, cs.Log.V_hat)
		//proof := make([]hashid.HashId, 0)

		in.Chm.C = cs.C
		in.Chm.Vote = cs.Vote
	} else { // we are a leaf
		// register challenge
		cs.C = in.Chm.C
		//cs.Round.MTRoot = chm.MTRoot
	}
	// compute response share already + localmerkle proof
	cs.InitResponseCrypto()

	// Inform all children of announcement - just copy the one that came in
	for i := range out {
		out[i].Chm.C = in.Chm.C
		out[i].Chm.Vote = in.Chm.Vote
	}

	return nil
}

// TODO make that sms == nil in case we are a leaf to stay consistent with
// others calls
func (cs *RoundCosi) Response(sms []*sign.SigningMessage, out *sign.SigningMessage) error {
	// initialize exception handling
	exceptionV_hat := cs.Suite.Point().Null()
	exceptionX_hat := cs.Suite.Point().Null()
	cs.ExceptionList = make([]abstract.Point, 0)
	nullPoint := cs.Suite.Point().Null()

	children := cs.Children
	for _, sm := range sms {
		from := sm.From
		switch sm.Type {
		default:
			// default == no response from child
			// dbg.Lvl4(sn.Name(), "default in respose for child", from, sm)
			if children[from] != nil {
				cs.ExceptionList = append(cs.ExceptionList, children[from].PubKey())

				// remove public keys and point commits from subtree of failed child
				cs.Add(exceptionX_hat, cs.ChildX_hat[from])
				cs.Add(exceptionV_hat, cs.ChildV_hat[from])
			}
			continue
		case sign.Response:
			// disregard response from children who did not commit
			_, ok := cs.ChildV_hat[from]
			if ok == true && cs.ChildV_hat[from].Equal(nullPoint) {
				continue
			}

			// dbg.Lvl4(sn.Name(), "accepts response from", from, sm.Type)
			cs.R_hat.Add(cs.R_hat, sm.Rm.R_hat)

			cs.Add(exceptionV_hat, sm.Rm.ExceptionV_hat)

			cs.Add(exceptionX_hat, sm.Rm.ExceptionX_hat)
			cs.ExceptionList = append(cs.ExceptionList, sm.Rm.ExceptionList...)

		case sign.Error:
			if sm.Err == nil {
				dbg.Lvl2("Error message with no error")
				continue
			}

			// Report up non-networking error, probably signature failure
			dbg.Lvl2(cs.Name, "Error in respose for child", from, sm)
			err := errors.New(sm.Err.Err)
			return err
		}
	}

	// remove exceptions from subtree that failed
	cs.Sub(cs.X_hat, exceptionX_hat)
	cs.ExceptionV_hat = exceptionV_hat
	cs.ExceptionX_hat = exceptionX_hat

	dbg.Lvl4(cs.Name, "got all responses")
	err := cs.VerifyResponses()
	if err != nil {
		dbg.Lvl3(cs.Node.Name(), "Could not verify responses..")
		return err
	}
	rm := &sign.ResponseMessage{
		R_hat:          cs.R_hat,
		ExceptionList:  cs.ExceptionList,
		ExceptionV_hat: cs.ExceptionV_hat,
		ExceptionX_hat: cs.ExceptionX_hat,
	}
	out.Rm = rm
	return nil
}

func (cs *RoundCosi) SignatureBroadcast(in *sign.SigningMessage, out []*sign.SigningMessage) error {
	// Root is creating the sig broadcast
	sb := in.SBm
	if cs.Node.IsRoot(cs.View) {
		dbg.Lvl2(cs.Node.Name(), ": sending number of messages:", cs.Node.Messages)
		sb.R0_hat = cs.R_hat
		sb.C = cs.C
		sb.X0_hat = cs.X_hat
		sb.V0_hat = cs.Log.V_hat
		sb.Messages = cs.Node.Messages
	} else {
		cs.Node.Messages = sb.Messages
	}

	// Inform all children of broadcast  - just copy the one that came in
	for i := range out {
		out[i].SBm = sb
	}

	return nil
}

// Called by every node after receiving aggregate responses from descendants
func (cs *RoundCosi) VerifyResponses() error {
	// TODO: redo VerifyResponses
	/*
	// Check that: base**r_hat * X_hat**c == V_hat
	// Equivalent to base**(r+xc) == base**(v) == T in vanillaElGamal
	Aux := cs.Suite.Point()
	V_clean := cs.Suite.Point()
	V_clean.Add(V_clean.Mul(nil, cs.R_hat), Aux.Mul(cs.X_hat, cs.C))
	// T is the recreated V_hat
	T := cs.Suite.Point().Null()
	T.Add(T, V_clean)
	T.Add(T, cs.ExceptionV_hat)

	var c2 abstract.Secret
	isroot := cs.Parent == ""
	if isroot {
		// round challenge must be recomputed given potential
		// exception list
		msg := cs.Msg
		msg = append(msg, []byte(cs.MTRoot)...)
		cs.C = HashElGamal(cs.Suite, msg, cs.Log.V_hat)
		c2 = HashElGamal(cs.Suite, msg, T)
	}

	// intermediary nodes check partial responses aginst their partial keys
	// the root node is also able to check against the challenge it emitted
	if !T.Equal(cs.Log.V_hat) || (isroot && !cs.C.Equal(c2)) {
		return errors.New("Verifying ElGamal Collective Signature failed in " +
		cs.Name)
	} else if isroot {
		dbg.Lvl4(cs.Name, "reports ElGamal Collective Signature succeeded")
	}
	*/
	return nil
}

// Sets up a round according to the needs stated in the
// Announcementmessage.
func (cs *RoundCosi)MerkleSetup(view, RoundNbr int, am *AnnouncementMessage) error {
	// set up commit and response channels for the new round
	cs.Vote = am.Vote
	cs.Children = cs.Node.Children(view)
	cs.Parent = cs.Node.Parent(view)
	cs.View = view
	cs.PubKey = cs.Node.PubKey
	cs.PrivKey = cs.Node.PrivKey
	cs.Name = cs.Node.Name()
	cs.InitCommitCrypto()

	// update max seen round
	// TODO: re-implement lastseenround
	/*
	cs.Node.roundmu.Lock()
	cs.Node.LastSeenRound = max(cs.Node.LastSeenRound, RoundNbr)
	cs.Node.roundmu.Unlock()
	*/

	// the root is the only node that keeps track of round # internally
	if cs.Node.IsRoot(view) {
		cs.Node.RoundsAsRoot += 1
		// TODO: is cs.Node.Round needed if we have LastSeenRound
		cs.Node.Round = RoundNbr

		// Create my back link to previous round
		cs.Node.SetBackLink(RoundNbr)
		// sn.SetAccountableRound(Round)
	}
	return nil
}

// Create round lasting secret and commit point v and V
// Initialize log structure for the round
func (cs *RoundCosi) InitCommitCrypto() {
	// generate secret and point commitment for this round
	rand := cs.Suite.Cipher([]byte(cs.Name))
	cs.Log = SNLog{}
	cs.Log.v = cs.Suite.Secret().Pick(rand)
	cs.Log.V = cs.Suite.Point().Mul(nil, cs.Log.v)
	// initialize product of point commitments
	cs.Log.V_hat = cs.Suite.Point().Null()
	cs.Log.Suite = cs.Suite
	cs.Add(cs.Log.V_hat, cs.Log.V)

	cs.X_hat = cs.Suite.Point().Null()
	cs.Add(cs.X_hat, cs.PubKey)
}

func (cs *RoundCosi) InitResponseCrypto() {
	cs.R = cs.Suite.Secret()
	cs.R.Mul(cs.PrivKey, cs.C).Sub(cs.Log.v, cs.R)
	// initialize sum of children's responses
	cs.R_hat = cs.R
}


// Adding-function for crypto-points that accepts nil
func (cs *RoundCosi) Add(a abstract.Point, b abstract.Point) {
	if a == nil {
		a = cs.Suite.Point().Null()
	}
	if b != nil {
		a.Add(a, b)
	}
}

// Substraction-function for crypto-points that accepts nil
func (cs *RoundCosi) Sub(a abstract.Point, b abstract.Point) {
	if a == nil {
		a = cs.Suite.Point().Null()
	}
	if b != nil {
		a.Sub(a, b)
	}
}

func (cs *RoundCosi) IsRoot() bool {
	return cs.Parent == ""
}

func (cs *RoundCosi) IsLeaf() bool {
	return len(cs.Children) == 0
}
