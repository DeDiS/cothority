diff --git a/overlay.go b/overlay.go
index 8d8e480..4c855da 100644
--- a/overlay.go
+++ b/overlay.go
@@ -158,6 +158,11 @@ func (o *Overlay) TransmitMsg(onetMsg *ProtocolMsg, io MessageProxy) error {
 		// request the PI from the Service and binds the two
 		pi, err = o.server.serviceManager.newProtocol(tni, config)
 		if err != nil {
+			log.Print(o.ServerIdentity(), "closing")
+			o.instancesLock.Lock()
+			o.nodeDelete(onetMsg.To)
+			o.instancesLock.Unlock()
+			log.Print(o.ServerIdentity(), "closing done")
 			return err
 		}
 		if pi == nil {
diff --git a/server.go b/server.go
index 5151248..c043dae 100644
--- a/server.go
+++ b/server.go
@@ -159,6 +159,10 @@ func (c *Server) Close() error {
 	}
 	c.Unlock()
 
+	err := c.Router.Stop()
+	if err != nil {
+		log.Error("While stopping router:", err)
+	}
 	// For all services that have `TestClose` defined, call it to make
 	// sure they are able to clean up. This should only be used for tests!
 	c.serviceManager.servicesMutex.Lock()
@@ -177,11 +181,10 @@ func (c *Server) Close() error {
 	wg.Wait()
 	c.WebSocket.stop()
 	c.overlay.Close()
-	err := c.serviceManager.closeDatabase()
+	err = c.serviceManager.closeDatabase()
 	if err != nil {
 		log.Lvl3("Error closing database: " + err.Error())
 	}
-	err = c.Router.Stop()
 	log.Lvl3("Host Close", c.ServerIdentity.Address, "listening?", c.Router.Listening())
 	return err
 }
diff --git a/service.go b/service.go
index 88784f5..d95b4d3 100644
--- a/service.go
+++ b/service.go
@@ -426,6 +426,10 @@ func (s *serviceManager) serviceByID(id ServiceID) (Service, bool) {
 // the creation of the PI. Otherwise the service is responsible for setting up
 // the PI.
 func (s *serviceManager) newProtocol(tni *TreeNodeInstance, config *GenericConfig) (pi ProtocolInstance, err error) {
+	if s.server.Closed() {
+		err = errors.New("will not pass protocol once the server is closed")
+		return
+	}
 	si, ok := s.serviceByID(tni.Token().ServiceID)
 	defaultHandle := func() (ProtocolInstance, error) { return s.server.protocolInstantiate(tni.Token().ProtoID, tni) }
 	if !ok {
diff --git a/treenode.go b/treenode.go
index 549d351..3233852 100644
--- a/treenode.go
+++ b/treenode.go
@@ -338,12 +338,18 @@ func (n *TreeNodeInstance) Shutdown() error {
 
 // closeDispatch shuts down the go-routine and calls the protocolInstance-shutdown
 func (n *TreeNodeInstance) closeDispatch() error {
-	log.Lvl3("Closing node", n.Info())
+	defer func() {
+		if r := recover(); r != nil {
+			log.Print("Recovered in f", r)
+			log.Print(log.Stack())
+		}
+	}()
+	log.LLvl3("Closing node", n.Info())
 	n.msgDispatchQueueMutex.Lock()
 	n.closing = true
 	close(n.msgDispatchQueueWait)
 	n.msgDispatchQueueMutex.Unlock()
-	log.Lvl3("Closed node", n.Info())
+	log.LLvl3("Closed node", n.Info())
 	pni := n.ProtocolInstance()
 	if pni == nil {
 		return errors.New("Can't shutdown empty ProtocolInstance")
