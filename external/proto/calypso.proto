syntax = "proto2";
package calypso;
import "byzcoin.proto";
import "onet.proto";

option java_package = "ch.epfl.dedis.lib.proto";
option java_outer_classname = "Calypso";

// ***
// Common structures
// ***

// Write is the data stored in a write instance. It stores a reference to the LTS
// used and the encrypted secret.
message Write {
  // Data should be encrypted by the application under the symmetric key
  // in U and C
  required bytes data = 1;
  // U is the encrypted random value for the ElGamal encryption
  required bytes u = 2;
  // Ubar, E and f will be used by the server to verify the writer did
  // correctly encrypt the key. It binds the policy (the darc) with the
  // cyphertext.
  // Ubar is used for the log-equality proof
  required bytes ubar = 3;
  // E is the non-interactive challenge as scalar
  required bytes e = 4;
  // f is the proof - written in uppercase here so it is an exported
  // field, but in the OCS-paper it's lowercase.
  required bytes f = 5;
  // C is the ElGamal parts for the symmetric key material (might also
  // contain an IV)
  required bytes c = 6;
  // ExtraData is clear text and application-specific
  optional bytes extradata = 7;
  // LTSID points to the identity of the lts group
  required bytes ltsid = 8;
}

// Read is the data stored in a read instance. It has a pointer to the write
// instance and the public key used to create the read instance.
message Read {
  required bytes write = 1;
  required bytes xc = 2;
}

// ***
// These are the messages used in the API-calls
// ***

// Authorise is used to add the given ByzCoinID into the list of
// authorised IDs.
message Authorise {
  required bytes byzcoinid = 1;
}

// AuthoriseReply is returned upon successful authorisation.
message AuthoriseReply {
}

// CreateLTS is used to start a DKG and store the private keys in each node.
// Prior to using this request, the Calypso roster must be recorded on the
// ByzCoin blockchain in the instance specified by InstanceID.
message CreateLTS {
  required byzcoin.Proof proof = 1;
}

// CreateLTSReply is returned upon successfully setting up the distributed
// key.
message CreateLTSReply {
  required bytes byzcoinid = 1;
  required bytes instanceid = 2;
  // X is the public key of the LTS.
  required bytes x = 3;
}

// ReshareLTS is used to update the LTS shares. Prior to using this request,
// the Calypso roster must be updated on the ByzCoin blockchain in the instance
// specified by InstanceID.
message ReshareLTS {
  required byzcoin.Proof proof = 1;
}

// ReshareLTSReply is returned upon successful resharing. The LTSID and the
// public key X should remain the same.
message ReshareLTSReply {
}

// DecryptKey is sent by a reader after he successfully stored a 'Read' request
// in byzcoin Client.
message DecryptKey {
  // Read is the proof that he has been accepted to read the secret.
  required byzcoin.Proof read = 1;
  // Write is the proof containing the write request.
  required byzcoin.Proof write = 2;
}

// DecryptKeyReply is returned if the service verified successfully that the
// decryption request is valid.
message DecryptKeyReply {
  // C is the secret re-encrypted under the reader's public key.
  required bytes c = 1;
  // XhatEnc is the random part of the encryption.
  required bytes xhatenc = 2;
  // X is the aggregate public key of the LTS used.
  required bytes x = 3;
}

// GetLTSReply asks for the shared public key of the corresponding LTSID
message GetLTSReply {
  // LTSID is the id of the LTS instance created.
  required bytes ltsid = 1;
}

// LtsInstanceInfo is the information stored in an LTS instance.
message LtsInstanceInfo {
  required onet.Roster roster = 1;
}

//
// V4 proposed extensions
//

// Auth holds all possible authentication structures. When using it to call
// Authorise, only one of the fields must be non-nil.
message Auth {
  optional AuthByzCoin byzcoin = 1;
  optional AuthX509Cert authx509cert = 2;
}

// AuthByzCoin holds the information necessary to authenticate a byzcoin request.
// In the ByzCoin model, all requests are valid as long as they are stored in the
// blockchain with the given ID.
// The TTL is to avoid that too old requests are re-used. If it is 0, it is disabled.
message AuthByzCoin {
  required bytes byzcoinid = 1;
  required uint64 ttl = 2;
}

// AuthX509Cert holds the information necessary to authenticate a HyperLedger/Fabric
// request. In its simplest form, it is simply the CA that will have to sign the
// certificates of the requesters.
// The Threshold indicates how many clients must have signed the request before it
// is accepted.
message AuthX509Cert {
  // Slice of ASN.1 encoded X509 certificates.
  repeated bytes ca = 1;
  required sint32 threshold = 2;
}

// Grant holds one of the possible grant proofs for a reencryption request. Each
// grant proof must hold the secret to be reencrypted, the ephemeral key, as well
// as the proof itself that the request is valid. For each of the authentication
// schemes, this proof will be different.
message Grant {
  optional GrantByzCoin byzcoin = 1;
  optional GrantX509Cert x509cert = 2;
}

// GrantByzCoin holds the proof of the write instance, holding the secret itself.
// The proof of the read instance holds the ephemeral key. Both proofs can be
// verified using one of the stored ByzCoinIDs.
message GrantByzCoin {
  // Write is the proof containing the write request.
  required byzcoin.Proof write = 1;
  // Read is the proof that he has been accepted to read the secret.
  required byzcoin.Proof read = 2;
}

// GrantX509Cert holds the proof that at least a threshold number of clients
// accepted the reencryption.
// For each client, there must exist a certificate that can be verified by the
// CA certificate from AuthX509Cert. Additionally, each client must sign the
// following message:
//   sha256( Secret | Ephemeral | Time )
message GrantX509Cert {
  required bytes secret = 1;
  repeated bytes certificates = 2;
}
