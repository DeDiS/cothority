// This file contains all the code to SETUP (setup.go) a randhoundco system and launch
// rounds of JVSS-based CoSi protocol (round.go).
package randhoundco

import (
	"sync"

	cosip "github.com/dedis/cosi/protocol"
	"github.com/dedis/cothority/log"
	"github.com/dedis/cothority/protocols/jvss"
	"github.com/dedis/cothority/sda"
)

const FullProto = "FullProto"

func init() {
	sda.GlobalProtocolRegister(FullProto, NewNodeProtocol)
}

// fullProto controls the logic from the setup of a randhounco system to a
// randmness generation round.
type fullProto struct {
	*sda.TreeNodeInstance
	// the jvss protocol instantiated by the setup protocol
	jvStore *jvssStore
	// forces the protocol to accept only one round at a time
	roundMut sync.Mutex
	// HACK: this cosi protocol catches all cosi related messages. On
	// announcement, fullProto will create the roundLeader. This roundLeader
	// creates a CoSi protocol which will overwrite the different messages of
	// the cosi protocol it can run fine.
	catch *cosip.CoSi
	// controls whether this protocol should finish or not
	*onDone

	// the setup protocol - root node point of view
	setupRoot *setupRoot
	// the setup protocol - non-root node point of view
	setupNode *setupNode
	// the groups generated by the setup
	grStore *groupsStore
}

func newFullProto(n *sda.TreeNodeInstance) (*fullProto, error) {
	p, err := cosip.NewCoSi(n)
	go p.Dispatch()
	cm := &fullProto{
		TreeNodeInstance: n,
		catch:            p.(*cosip.CoSi),
		onDone:           &onDone{},
		jvStore:          newJvssStore(),
	}
	// don't release our TreeNodeInstance
	cm.OnDoneCallback(cm.onDoneCB)
	return cm, err
}

func NewRootProtocol(n *sda.TreeNodeInstance, groups GroupRequests) (sda.ProtocolInstance, error) {
	pc, err := newFullProto(n)
	if err != nil {
		return nil, err
	}

	setup, err := NewSetupRoot(n, groups)
	if err != nil {
		return nil, err
	}

	pc.setupRoot = setup
	pc.grStore = newGroupsStore()

	// save the jvss protocol when created
	pc.setupRoot.RegisterOnJVSS(func(jv *jvss.JVSS) {
		pc.jvStore.store(jv)
	})

	return pc, nil
}

func NewNodeProtocol(n *sda.TreeNodeInstance) (sda.ProtocolInstance, error) {
	pl, err := newFullProto(n)
	if err != nil {
		return nil, err
	}
	setup, err := NewSetupNode(n)
	if err != nil {
		return nil, err
	}

	pl.setupNode = setup
	// catch announcements
	pl.catch.RegisterAnnouncementHook(pl.onCoSiAnnouncement)
	// save the jvss protocol when created
	pl.setupNode.RegisterOnJVSS(func(jv *jvss.JVSS) {
		pl.jvStore.store(jv)
	})

	// handler for receiving group request
	//pl.RegisterHandler(pl.onGroups)
	return pl, err
}

// Start the system setup protocol. It is a blocking call until the setup phase
// is done.
func (fp *fullProto) Start() error {
	var done = make(chan bool)
	fp.setupRoot.RegisterOnSetupDone(func(g *Groups) {
		fp.grStore.store(g)
		done <- true
		// broadcast the groups to all the leaders
		/*if err := pc.SendToChildren(g); err != nil {*/
		//log.Error(err)
		/*}*/
	})
	log.Lvl2(fp.Name(), "Starting the full setup protocol")
	fp.setupRoot.Start()
	<-done
	log.Lvl2(fp.Name(), "Finished the full setup")
	return nil
}

func (fp *fullProto) Done() {
	log.Lvl2(fp.Name(), "Done()")
	fp.setDone()
	fp.catch.Done()
}

// Groups wait the grouping generation from the setup protocol to finish and
// returns it.
func (fp *fullProto) Groups() *Groups {
	if fp.grStore == nil {
		panic("You ask the wrong node to get the Groups")
	}
	return fp.grStore.get()
}

// NewRound starts a new round of the jvss-based CoSi round and returns the
// resulting signature once it's ready.
func (fp *fullProto) NewRound(msg []byte) (sig []byte, err error) {
	if fp.setupRoot == nil {
		panic("I should not asked to do this")
	}

	// one round at a time
	fp.roundMut.Lock()
	defer fp.roundMut.Unlock()
	groups := fp.Groups()
	jvProto := fp.jvStore.get()
	log.Lvl2(fp.Name(), "Root's NewRound() on ", len(msg), "bytes with jv ", jvProto.Name())
	p, err := NewRoundRoot(fp.TreeNodeInstance, msg, groups.Aggregate, jvProto)
	fp.catch.RegisterAnnouncementHook(fp.onCoSiAnnouncement)
	if err != nil {
		return
	}
	round := p.(*roundRoot)

	sigCh := make(chan []byte)
	round.RegisterOnSignature(func(roundSig []byte) {
		sigCh <- roundSig
	})

	go round.Start()
	return <-sigCh, nil
}

// onCoSiAnnouncement is a HACK in order to create the round protocol with the
// JVSS protocol instance. This announcement will be dispatched to the round
// protocol.
func (fp *fullProto) onCoSiAnnouncement(in *cosip.Announcement) error {
	// one round at a time
	fp.roundMut.Lock()
	defer fp.roundMut.Unlock()
	jvProto := fp.jvStore.get()
	p, err := NewRoundNode(fp.TreeNodeInstance, jvProto)
	if err != nil {
		return err
	}
	round := p.(*roundNode)
	// only register the catch when the NewRoundNode is finished
	round.RegisterOnDone(func() {
		fp.setupCatch()
	})
	return round.onAnnouncement(in)
}

func (fp *fullProto) setupCatch() {
	if fp.catch != nil {
		fp.catch.Done()
	}
	p, err := cosip.NewCoSi(fp.TreeNodeInstance)
	if err != nil {
		log.Error(err)
	}
	go p.Dispatch()
	fp.catch = p.(*cosip.CoSi)
	fp.catch.RegisterAnnouncementHook(fp.onCoSiAnnouncement)
}

// onDone keeps track of whether it has beek asked to close or only
// sub-protocols have closed.
type onDone struct {
	sync.Mutex
	done bool
}

func (o *onDone) onDoneCB() bool {
	o.Lock()
	defer o.Unlock()
	return o.done
}

func (o *onDone) setDone() {
	o.Lock()
	defer o.Unlock()
	o.done = true
}

// groupsStore is a thread safe way to wait for hte storage of one Groups
// struct.
type groupsStore struct {
	*sync.Cond
	g *Groups
}

func newGroupsStore() *groupsStore {
	return &groupsStore{
		Cond: sync.NewCond(&sync.Mutex{}),
	}
}

func (gs *groupsStore) store(g *Groups) {
	gs.L.Lock()
	gs.g = g
	gs.L.Unlock()
	gs.Broadcast()
}

func (gs *groupsStore) get() *Groups {
	gs.L.Lock()
	for gs.g == nil {
		gs.Wait()
	}
	defer gs.L.Unlock()
	return gs.g
}

// jvssStore is a thread safe way to store and retrieve a jvss protocol instance
type jvssStore struct {
	*sync.Cond
	jv *jvss.JVSS
}

func newJvssStore() *jvssStore {
	return &jvssStore{
		Cond: sync.NewCond(&sync.Mutex{}),
	}
}
func (j *jvssStore) store(jv *jvss.JVSS) {
	j.L.Lock()
	j.jv = jv
	j.L.Unlock()
	j.Broadcast()
}

func (j *jvssStore) get() *jvss.JVSS {
	j.L.Lock()
	for j.jv == nil {
		j.Wait()
	}
	defer j.L.Unlock()
	return j.jv
}
